\documentclass[12pt]{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

\usepackage[backend=biber,style=numeric]{biblatex}
\addbibresource{reference.bib}

% Useful packages
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{Vehicle Self-Speed Adjustment Model}
\author{Ruiqi Chu \\ 
Department of Mathematics, UC San Diego}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
This paper would like to discuss the implementation of vehicle self-speed adjustment using mathematical models employing the linear and modified-Sigmoid functions. It aims to simulate an Adaptive Cruise Control environment by adjusting the velocity of the ego car and maintaining a safe following distance with representation of graphs. 
\end{abstract}

\section*{Introduction}

Vehicle intelligence is on a rise in recent years. Increasing cars are equipped with driver assistance technology, for instance, auto line keeping, auto breaking, speed assists, etc. Other than these features the most fascinating automobile intelligence system would be the full self-driving system from companies like Tesla and Waymo. Vehicles equipped with this system can drive autonomously with a driver present, like the Tesla full self-driving (Supervised) mode, or without a driver, such as Waymo’s self-driving taxi. Trying to understand the full technology behind these cars will be complex, but breaking up the system it will be easier to see that there are many smaller functions, which are easier to study and understand. One of the most essential functions in autonomous cars is self-distance balancing. This function is also widely used in other nonautonomous cars known as the Adaptive Cruise Control (ACC). 

\subsection*{History }
ACC emerged as an evolution of traditional cruise control, first introduced in the 1950s by Chrysler under the name ``Auto-Pilot." Traditional cruise control allowed drivers to maintain a constant speed but required manual braking and acceleration. In the 1990s, Mitsubishi pioneered ACC technology with the ``Preview Distance Control" system, using lidar to monitor and adjust speed based on the distance to the vehicle ahead. Early ACC systems were limited to low-speed or highway conditions. By the early 2000s, advancements in radar and camera systems enabled more reliable and adaptive functionality, allowing vehicles to handle varying traffic scenarios ~\cite{adas_features} ~\cite{automated_driving_history}.


\section*{Background}
ACC is vital for improving road safety, reducing rear-end collisions, and enhancing traffic efficiency by minimizing ``stop-and-go" driving. It supports fuel economy and lowers emissions by maintaining optimal speed profiles, contributing to environmental sustainability. ACC also enhances driver comfort by automating speed control and reducing stress on long journeys, while its integration with advanced systems lays the foundation for autonomous driving. By reducing accidents, traffic congestion, and vehicle wear, ACC offers significant economic benefits and aligns with the global push toward safer, more efficient, and sustainable transportation systems \cite{kbb_adaptive_cruise_control}.

Moreover, for the purpose of building this mathematical model, I do not want to consider accidental events or system failures, for instance camera or radar detection error, suddenly appeared objects, system response time, or other emergency situations which may affect the system response time of the vehicle. I am also not assuming the front car have the same brake distance as me so maintaining a safe distance is essential to avoid multi-vehicle collisions.

\subsection*{Car Model Specification}

\indent To maintain consistency in this report, I selected the Tesla Model 3 RWD, model year 2023 (abbreviated as M3). This model is a fully electric, four-door sedan with a length of 184.8 inches, a width of 82.2 inches (including mirrors), and a weight of 3,862 pounds. According to Tesla, the M3 accelerates from 0 to 60 mph in 5.8 seconds, which equals approximately 10.34 miles per second, and has a top speed of 139.8 mph ~\cite{tesla_m3_evspecs}.

All Tesla vehicles come equipped with Traffic-Aware Cruise Control, which have exact same function as ACC that adjusts the car's speed to match surrounding traffic and maintains a safe following distance from the vehicle ahead \cite{kbb_adaptive_cruise_control}. This feature is particularly useful for testing the auto-speed adjustment system during the early stages of this project \cite{tesla_model3_manual}. 

\subsection*{Input Measurements and Assumptions}
The result of this self-speed adjustment model will be presented as a Python program where the user will be asked to input values to build the model. The input measurements and user customizations I am taking as input to mimic the real-world situation are: 
\begin{itemize}
    \item \textbf{Ego Car Speed:} The current speed of the car being monitored, adjusted using the model to achieve vehicle self-speed adjustment.
    \item \textbf{Front Car Speed:} The speed of the car in front of the ego car. Due to the limitation of not having real-time results, it is assumed that the front car is moving at a constant speed, which remains the same as the user input. In practical scenarios, the speed of the front car can be measured in milliseconds or less for more accurate real-time results.
    \item \textbf{Following Distance:} The distance from the rear end of the front car to the bumper of the ego car. This is taken as a user input; however, in real-world situations, it can be measured using computer vision or radar.
    \item \textbf{ACC Speed:} The Adaptive Cruise Control speed specified by the user. This represents the speed at which the driver wants the car to be driven.
\end{itemize}


\section*{Following Distance}

In order to achieve a safe self-driving environment, it is crucial to determine a safe following distance at all speeds. One of the most used techniques for drivers to determine a safe distance is the 3 second rule. How this method works is the driver will choose a stationary object on the side of the road, such as a signpost, tree, or overpass, as a reference point. When the vehicle in front passes the reference point, the driver begins counting ``one thousand one, one thousand two, one thousand three". If the vehicle reaches the same reference point before the driver finishes counting to three, they are following too closely, and the driver should slow down to increase the following distance ~\cite{esc_three_second_rule}. However, the same rule does not apply to all road conditions or speeds. The three second rule would be highly applicable to average highway speeds in the range of 55 mph to 85 mph. When the driver is driving slower than 55 mph, a lesser following distance would be sufficient, and the driver could count two seconds using the same method. When the driver is speeding over 85 mph, they could count one additional second for longer and safer following distance. To find the safe following distance, I decide to implement the three second rule to an equation in finding the following distance. 

\subsection*{Safe Following Distance Model}

To find the safe following distance formula, I first need to measure the current speed of the ego car and the front car. For this simulation, I am taking these measurements as custom inputs in the Python program. After measuring the speeds, it needs to be converted into miles per second by dividing velocity by 60 minutes times 60 seconds, which is the number of seconds in one hour. Since miles per second would be a very small decimal, converting from miles to feet per second would be better to read and visualize. After the conversions, the feet per second is ready to be implemented in the three seconds’ rule. Then I multiply distance per second to the number of seconds accordingly.
The number of seconds would be specialized from 2 to 4 seconds. Like what I described above, two would be implemented into cases when the car is driving under 55 mph. For velocity between 55 to 85 mph, I implemented a formula for gradual change of 2 through 4 seconds: 
\[
\text{Number of Seconds} = 2 + 2 \cdot \frac{\text{Current Speed} - 55}{85 - 55}.
\]
The formula calculates the "Number of Seconds" as a function of the difference between the current speed of the vehicle and the reference speed (55 mph). This difference is normalized by dividing by the range between 85 mph and 55 mph, ensuring that the result is proportional to the speed within this range. Additionally, 4 seconds is used for cases over and including 85 mph. I can now compute the safe following distance using number of seconds I got. A general formula for safe following distance would look like:

\begin{equation}
\text{Safe Following Distance} = \frac{\text{Number of Seconds} \cdot \text{mph}}{3600} \cdot 5280.
\label{eq:following_distance}
\end{equation}
In order to validate my following distance formula, I researched different websites articles with average stopping distance for sedans. Stopping distance is the total distance a vehicle travels from the moment the driver decides to stop until the vehicle comes to a complete stop. Comparing their values with my safe following distance model, the distance I got are greater then or no less than -3\% of the stopping distance stated in the articles which ensures safety \cite{brake_stopping_distances}.

\section*{Ego Car Velocity}
How ACC works in real life is that when the user first chooses a speed they want the car to stay constant. Then the car will accelerate if the ego speed is below the user input ACC speed and the current following distance is over safe following distance. Alternatively, the vehicle will decelerate when ACC speed is less than ego speed, or current following distance is less than safe following distance. It will also stay at the input ACC speed if the ego speed is the same as ACC speed and has a safe following distance. 
Similar to the actual ACC system, the ego car for my model should have one of three actions, acceleration, deceleration, or keeping the current speed depending on the user input and calculations. I also want to prioritize safety over ACC speed. Therefore, my model will determine the safe following distance first before trying to achieve the ACC speed. 

\subsection*{Linear Model}
Whenever the ego car needs to change speeds, the most straightforward way is to model acceleration or deceleration using a linear equation. The model needs a starting speed, which will be the speed my ego vehicle is currently at. It also needs a constant acceleration which the vehicle’s speed increases and decreases. Then we also need the time, which is the duration of the speed change to achieve the target. The general linear model I want to implement is:

\begin{equation}
V_L(t) = \text{Ego Speed (mph)} +  \text{Constant Acceleration (mph/s)} \cdot \text{t (s)}.
\label{eq:velocity_equation}
\end{equation}



\subsection*{Keeping Current Speed Model} 
The ego car will maintain a constant speed when the Ego speed equals the ACC speed with the condition of following distance is greater than or equal to the safe following distance, as calculated by the model (1). In this case, the ego car’s speed remains constant with zero acceleration.

\subsection*{Smooth Model}

\indent In addition to the linear model, I built another smoother curved model for a more energy efficient way to better monitor real world situations. For the smooth model, I want my ego car to have a lesser acceleration at the beginning and gradually increase until the midpoint, which will have the greatest acceleration, and then slowly decrease until it reaches the desired speed. For this model, I researched the sigmoid function \cite{sigmoid_function_sciencedirect}, which is a good representation for what I want my model to output.
The standard sigmoid function is defined as:
\[
S(x) = \frac{1}{1 + e^{-x}}.
\]
The sigmoid function is a S-shaped curve in which the output values of S(x) range between 0 and 1. At x = 0, the function has an output of 0.50 and it is the steepest slope shown in Figure \ref{fig:Sigmoid}.

\begin{figure}[h!]  % The figure environment allows for better control of image placement
\centering
\includegraphics[width=0.5\textwidth]{Logistic-curve.svg.png}  % Replace 'example.jpg' with your file name
\caption{Sigmoid function}
\label{fig:Sigmoid}
\end{figure}

To fit the sigmoid equation for velocity adjustment, I need the x-axis to be time and y-axis to be velocity and shift the curve to be in the first quadrant. 

\noindent The final equation I get by stretching and modifying is: 
\begin{equation}
V_S(t) = \text{Ego Speed} + \alpha \cdot \frac{\text{Target Speed} - \text{Ego Speed}}{1 + e^{-k \cdot (t - t_0)}}.
\label{eq:velocity_s}
\end{equation}

The initial step was to rescale the \( y \)-axis. The standard sigmoid function \( S(x) \) outputs values in the range \([0,1]\), where \( S(x) \to 0 \) as \( x \to -\infty \) and \( S(x) \to 1 \) as \( x \to +\infty \). Let \(v_{\max} = \max(\text{Target Speed, Ego Speed)}\), and \(v_{\min} = \min(\text{Target Speed, Ego Speed)}\). Rescaling the range of the sigmoid's output from \([0,1]\) to the velocity range \([v_{\min}, v_{\max}]\) is an efficient way to represent velocity changes.

In this case, \( v_{\min} \) corresponds to \( S(x) = 0 \), and \( v_{\max} \) corresponds to \( S(x) = 1 \). Rescaling \( S(x) \) by multiplying it with \((v_{\max} - v_{\min})\) transforms the output to the desired velocity range. After scaling, the minimum velocity of \( S(x) \) remains 0. To achieve the desired minimum velocity, we then offset the scaled sigmoid function by a constant \( v_{\min} \).

For acceleration, we add \( v_{\min} \) to \( (v_{\max} - v_{\min}) \cdot S(x) \), which shifts the entire scaled sigmoid curve upward by \( v_{\min} \). For deceleration, the direction of \( S(x) \) is reversed, resulting in:
\[
v_{\max} -(v_{\max} - v_{\min}) \cdot S(x).
\]
To generalize both acceleration and deceleration, I introduce a parameter \( \alpha \) that takes the value \( +1 \) for acceleration and \( -1 \) for deceleration. This way, the same equation can be used for both cases.

Since acceleration and deceleration typically occur over a specific time frame, the \( x \)-axis must be adjusted to reflect this period. The Sigmoid's transition is shifted from \( x = 0 \) to \( t = t_0 \) by substituting \( x \) with \( (t - t_0) \). Additionally, \( x \) in the original function controls the steepness of the sigmoid. Introducing a steepness parameter \( k \) as a multiplier to \( (t - t_0) \) allows for tuning the rate of change. A smaller \( k \) produces a more gradual transition, while larger \( k \) values result in sharper transitions.


\section*{Simulation}
There are two cases I want my model to simulate. One being the current following distance greater than or equal to the safe following distance, and the other having an unsafe following distance. I will specify both cases with the linear model and smooth model.

\subsection*{Safe Following Distance}
In cases where the imputed ACC speed is greater than or less than the ego speed, and the current following distance is safe, the ego car should accelerate or decelerate to the set speed.\vspace{1em} \\
\textbf{1. Linear Model} \\
\indent Based on my own investigation of driving with ACC technology, the system approximately accelerates or decelerates at a rate of 1 mph/s to 2 mph/s to achieve the targeted ACC speed. For this linear model, I will take the mean value and use a constant acceleration of 1.5 mph/s. My model for the safe following distance becomes:
\[
V_L'(t) = \text{Ego Speed (mph)} \pm 1.5 \, \text{(mph/s)} \cdot \text{t (s)},
\]
where a positive value of 1.5 mph/s is assigned during acceleration, and a negative value is assigned during deceleration.\vspace{1em} \\
\textbf{2. Smooth Model} \\
\indent The ego car will accelerate or decelerate gradually according to the smooth model \eqref{eq:velocity_s}. To implement \( V_S(t) \), it is necessary to determine the total time required to reach the target speed. For simplicity, I have defined the total time as \( | \text{target speed} - \text{ego speed} | \), which implies an average acceleration or deceleration of 1 mph/s.

Regarding the output of the Python program, since this is a smooth model, velocity measurements must be recorded at smaller time intervals. Consequently, I computed the time using discrete time steps. A time step represents a fixed interval between successive updates in the simulation. I have chosen \( \Delta t = 0.1 \) seconds, and the total number of time steps is given by \( | \text{target speed} - \text{ego speed} | \times 10 \), ensuring consistency in the simulation time.

\subsection*{Unsafe Following Distance} 

\indent There are cases where the velocity of the front car is greater than the ego car, even with an unsafe following distance. Under these circumstances, acceleration to the ACC speed should be accepted, as the front car will always maintain a higher speed than the ego car as long as the ego car's speed remains lower than the front car's speed. In this case, it would be efficient to apply the same model used for maintaining a safe following distance.

In cases where the ego car has an unsafe following distance and its speed is less than or equal to the front car's speed, the program should instead respond with deceleration. This process can be separated into two steps for clarity and better control.\vspace{1em} \\
\textbf{1. Matching speed of the front car within specified time frame}\\

The time frame for this action is defined as the number of seconds before the ego car would collide with the front car if it does not slow down. This involves calculating the relative displacement between the ego car and the front car, factoring in their respective speeds, and converting values from mph to feet per second. The formula used is:

\[
\text{Relative Speed (ft/s)} = \frac{\text{Ego Speed (mph)} - \text{Front Speed (mph)}}{60 \cdot 60} \cdot 5280.
\]
To determine the time until the ego car reaches the front car:
\[
\text{Time to Change (s)} = \frac{\text{Following Distance (ft)}}{\text{Relative Speed (ft/s)}}.
\]
The deceleration rate I used is:
\[
\text{deceleration} = \frac{\text{Front Speed} - \text{Ego Speed}}{\text{time}}.
\]
The linear velocity model (2) is then implemented to decelerate the ego car to match the front car's speed.\vspace{1em} \\
\textbf{2. Calculate Time Based on Total Distance to Change}\\

In order to find the displacement caused by initial velocity adjustment, calculating the time for the ego car to adjust its speed is required using:
\[
\text{time} = \frac{\text{Front Speed} - \text{Ego Speed}}{\text{deceleration}}.
\]
where deceleration is the same as calculated in the previous step. During this time, the ego car covers a distance:
\[
\text{distance}_E = \text{Ego Speed} \cdot \text{t} + \frac{1}{2} \cdot \text{deceleration} \cdot \text{t}^2.
\]
This accounts for the distance traveled due to its initial speed and the additional distance caused by deceleration. Simultaneously, the front car travels a distance:
\[
\text{distance}_F = \text{Front Speed} \cdot \text{time}.
\]
as it moves at a constant speed. The remaining distance between the two cars is then calculated as:
\[
\text{Remaining Distance} = \text{distance}_F - \text{distance}_E.
\]
This represents how far apart the cars remain after the rear car has adjusted its speed.\\
Finally, the total current following distance after the initial deceleration is determined by adding the displacement distance to the initial following distance:

\begin{equation}
\text{Update Distance} = \text{Remaining Distance} + \text{Following Distance}.
\label{eq:updated_following_distance}
\end{equation}

Given the current following distance, determining the time required to achieve the desired following distance is essential. To address this, different equations were utilized in my Python program for the linear and smooth models.\vspace{0.5em} \\

\noindent \textbf{2.1. Linear Model}\\
\indent \setlength{\leftskip}{2em} The kinematic equation for motion was implemented to calculate the distance traveled during each simulation step in the linear model. Specifically, the distance covered by the ego car is computed as:

\[
\Delta \text{distance} = \text{Ego Speed} \cdot \Delta \text{t} + \frac{1}{2} \cdot \text{deceleration} \cdot (\Delta \text{t})^2,
\]
where \(\text{deceleration}\) is the constant deceleration rate (\(-1 \, \text{ft/s}^2\)) and \(\Delta \text{time}\) ($0.1$ \, \text{seconds}) is the time step. This computed distance, \(\Delta \text{distance}\), is then added to \eqref{eq:updated_following_distance} for a continuously updated following distance, i.e. we update this Update Distance to 
\[
\text{Update Distance} + \Delta d.
\]
The total seconds of time is also being updated each time step (\(\Delta \text{time}\)) to
\[
\text{t} + 0.1,
\]
with a starting time of 0 seconds. 

Concurrently, the safe following distance is recalculated using safe following distance formula \eqref{eq:following_distance}, and the ego car’s speed is iteratively reduced to simulate controlled deceleration according and updated to
\[
\text{Ego Speed} - 0.1.
\]

This iterative process continues until one of two conditions is met: 1) the adjusted distance, Update Distance, becomes greater than or equal to the safe following distance, \(\text{follow}\); or 2) a time limit of \(t > 100\) seconds is reached, ensuring the simulation does not run indefinitely.

This approach guarantees that the ego car achieves a safe following distance through a methodical process of controlled deceleration and returns a time to reach the safe following distance.\vspace{1 em} \\

\noindent \textbf{2.2. Smooth Model}\\
\indent Similar to the linear model above, during simulation loop for smooth model, the ego car's adjusted distance, \(\text{Update Distance}\), is compared to the required safe following distance\eqref{eq:following_distance}.

This safe following distance is dynamically recalculated based on the current speed of the ego car. At each time step (\(\Delta t = 0.1 \, \text{seconds}\)), the distance traveled by the ego car is determined by integrating the smooth velocity function \(V_S(t)\) over the interval \([t, t + \Delta t]\):

\[
\Delta \text{distance} = \int_t^{t+\Delta t} v(t) \, dt.
\]
This increment, \(\Delta d\), is then added to the cumulative adjusted following distance, i.e. we update this Update Distance
to
\[
\text{Update Distance} + \Delta \text{distance}.
\]

Subsequently, the time and ego speed is also adjusted accordingly just like the linear model. This iterative process continues until the adjusted distance either meets or exceeds the safe following distance or the simulation's time limit is reached.\vspace{1 em} \\

\setlength{\leftskip}{0em}
\noindent \textbf{3. Implement \(V_S(t)\) model.}\\

Right now we have got target speed and total time to achieve the safe following distance, thus we can implement the smooth model\eqref{eq:velocity_s} directly. 

\section*{Results}
For this section, I will walk through a example of how my program will work and output in achieving the desired speed and maintaining a safe following distance. 
\subsection*{User Inputs}
When the program runs, it will ask for some user inputs. The user inputs I am using for this example are: 
\begin{itemize}
  \item \textbf{Ego Speed:} 70 mph
  \item \textbf{Front Speed:} 60 mph
  \item \textbf{Following Distance:} 200 ft
  \item \textbf{Desired ACC Speed:} 70 mph
\end{itemize}

\subsection*{Explanation}
For this scenario, the ego car's speed exceeds the front car and the following distance is unsafe. Therefore, achieving the user specified ACC speed is inappropriate. Instead, the model will initiate deceleration. This process will first decelerate the ego car speed to the front car speed and then calculate and adjust to the safe following distance. 

\subsection*{Output}
\begin{itemize}
    \item \textbf{First Step: } Decelerate from 70 mph to 60 mph. 
    
    The Figure \ref{fig:Linear Velocity Change} is the output graph for my linear model. Figure \ref{fig:Smooth Velocity Change} is the output graph for my smooth model. The x-axis for both of my graphs represents the simulation time, and y-axis tracks vehicle's velocity over time as it decelerates to 60 mph. 
    
    \begin{figure}[h!] 
    \centering
    \includegraphics[width=0.5\textwidth]{Linear Model.png} 
    \caption{Linear Velocity Monitoring}
    \label{fig:Linear Velocity Change}
    \end{figure}

    \begin{figure}[h!] 
    \centering
    \includegraphics[width=0.5\textwidth]{Smooth Velocity.png}  
    \caption{Smooth Velocity Monitoring}
    \label{fig:Smooth Velocity Change}
    \end{figure}
    
    \item \textbf{Second Step: } The program computes the current following distance and estimates the time required to achieve a safe following distance. The calculations for both the linear and smooth models align with the methods detailed in the Unsafe Following Distance subsection of the Simulation section, reflecting the application of these models to adjust vehicle behavior dynamically.
    \item \textbf{Third Step: } Decelerate again to achieve safe following distance. 
    
    Figure \ref{fig:Achieve Safe D} shows the ego car following distance over time until reaching a safe following distance. The curve should be a positive slope since the following distance is increasing as a result of certain number of time steps. The program will also output a current speed after the adjustment, in this case, we have our ego car at speed of 59.6 mph with current following distance at 210.08 ft, which achieved the safe following distance. 
    
    \begin{figure}[h!]
    \centering
    \includegraphics[width=0.5\textwidth]{Achiving Safe FD.png} 
    \caption{Following Distance Adjustment}
    \label{fig:Achieve Safe D}
    \end{figure}
    
\end{itemize}


\section*{Conclusion}
In this report, I focused on maintaining a safe following distances while reaching the user desired ACC speed under safe autonomous driving conditions. By implementation of both linear and smooth models, the results indicate that my model and the Python program is successful to dynamically adjust the ego car's speed in relation to the front car and maintaining a safe following distance. In particular, the model correctly simulates the complex case of deceleration when the ego car is traveling at a higher speed than the front car, thus preventing unsafe following distances. This approach provides a sound basis for simulating basic adaptive cruise control systems, ensuring the vehicle adapts to traffic conditions efficiently.

However, there are many factors where my model can be further developed and improved. One of the potential area for improvement is to process more complex traffic conditions and implement lane changing to consider more emergency maneuvers. I could also take in more factors like weather or road conditions in determining the optimal speed of driving. 


\printbibliography

\end{document}
